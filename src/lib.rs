#![feature(slice_patterns)]

extern crate rustc_serialize;

pub struct Salsa20;

impl Salsa20 {

    pub fn hsalsa20(x: [u8; 64]) -> [u8; 32] {
        let mut xs = [0u32; 16];
        for i in 0..16 {
            xs[i] = little_endian([x[i*4], x[i*4+1], x[i*4+2], x[i*4+3]]);
        }

        // Run salsa20 double_round r/2 where r = 20 (HSalsa)
        let mut zs = xs;
        for _ in 0..10 {
            zs = Salsa20::double_round(zs);
        }

        let block: [u32; 8] = [zs[0], zs[5], zs[10], zs[15], zs[6], zs[7], zs[8], zs[9]];

        let mut rs = [0; 32];
        for i in 0..8 {
            let vs = little_endian_inv(block[i]);
            rs[i*4] = vs[0];
            rs[i*4+1] = vs[1];
            rs[i*4+2] = vs[2];
            rs[i*4+3] = vs[3];
        }
        rs
    }

    pub fn salsa20(x: [u8; 64]) -> [u8; 64] {
        let mut xs = [0u32; 16];
        for i in 0..16 {
            xs[i] = little_endian([x[i*4], x[i*4+1], x[i*4+2], x[i*4+3]]);
        }

        // Run salsa20 double_round r/2 where r= 20 (Salsa20/20)
        let mut zs = xs;
        for _ in 0..10 {
            zs = Salsa20::double_round(zs);
        }

        let mut rs = [0; 64];
        for i in 0..16 {
            let vs = little_endian_inv(zs[i].wrapping_add(xs[i]));
            rs[i*4] = vs[0];
            rs[i*4+1] = vs[1];
            rs[i*4+2] = vs[2];
            rs[i*4+3] = vs[3];
        }
        rs
    }

    pub fn quarter_round(y: [u32; 4]) -> [u32; 4] {
        let z1 = y[1] ^ (y[0].wrapping_add(y[3])).rotate_left(7);
        let z2 = y[2] ^ (z1.wrapping_add(y[0])).rotate_left(9);
        let z3 = y[3] ^ (z2.wrapping_add(z1)).rotate_left(13);
        let z0 = y[0] ^ (z3.wrapping_add(z2)).rotate_left(18);
        [z0, z1, z2, z3]
    }

    pub fn row_round(y: [u32; 16]) -> [u32; 16] {
        let [z0, z1, z2, z3] = Salsa20::quarter_round([y[0], y[1], y[2], y[3]]);
        let [z5, z6, z7, z4] = Salsa20::quarter_round([y[5], y[6], y[7], y[4]]);
        let [z10, z11, z8, z9] = Salsa20::quarter_round([y[10], y[11], y[8], y[9]]);
        let [z15, z12, z13, z14] = Salsa20::quarter_round([y[15], y[12], y[13], y[14]]);
        [ z0, z1, z2, z3, z4, z5, z6, z7, z8, z9, z10, z11, z12, z13, z14, z15 ]
    }

    pub fn column_round(x: [u32; 16]) -> [u32; 16] {
        let [y0, y4, y8, y12] = Salsa20::quarter_round([x[0], x[4], x[8], x[12]]);
        let [y5, y9, y13, y1] = Salsa20::quarter_round([x[5], x[9], x[13], x[1]]);
        let [y10, y14, y2, y6] = Salsa20::quarter_round([x[10], x[14], x[2], x[6]]);
        let [y15, y3, y7, y11] = Salsa20::quarter_round([x[15], x[3], x[7], x[11]]);
        [ y0, y1, y2, y3, y4, y5, y6, y7, y8, y9, y10, y11, y12, y13, y14, y15 ]
    }

    pub fn double_round(x: [u32; 16]) -> [u32; 16] {
        Salsa20::row_round(Salsa20::column_round(x))
    }

    pub fn salsa20_expansion_128(k: [u8; 16], n: [u8; 16]) -> [u8; 64] {
        let mut r = [0; 64];

        let t0 = [101, 120, 112, 97];
        for i in 0..4 {
            r[i] = t0[i];
        }
        for i in 0..16 {
            r[i+4] = k[i];
        }

        let t1 = [110, 100, 32, 49];
        for i in 0..4 {
            r[i+20] = t1[i];
        }
        for i in 0..16 {
            r[i+24] = n[i];
        }

        let t2 = [54, 45, 98, 121];
        for i in 0..4 {
            r[i+40] = t2[i];
        }
        for i in 0..16 {
            r[i+44] = k[i];
        }

        let t3 = [116, 101, 32, 107];
        for i in 0..4 {
            r[i+60] = t3[i];
        }

        r
    }

    pub fn salsa20_expansion_256(k0: [u8; 16], k1: [u8; 16], n: [u8; 16]) -> [u8; 64] {
        let mut r = [0; 64];

        let o0 = [101, 120, 112, 97];
        for i in 0..4 {
            r[i] = o0[i];
        }
        for i in 0..16 {
            r[i+4] = k0[i];
        }

        let o1 = [110, 100, 32, 51];
        for i in 0..4 {
            r[i+20] = o1[i];
        }
        for i in 0..16 {
            r[i+24] = n[i];
        }

        let o2 = [50, 45, 98, 121];
        for i in 0..4 {
            r[i+40] = o2[i];
        }
        for i in 0..16 {
            r[i+44] = k1[i];
        }

        let o3 = [116, 101, 32, 107];
        for i in 0..4 {
            r[i+60] = o3[i];
        }

        r
    }

    // Salsa20/20 128-bit key
    pub fn salsa20_20_128(k: [u8; 16], v: [u8; 8], m: Vec<u8>) -> Vec<u8> {
        let mut r = vec![0; m.len()];

        // for every 64 bytes generated by salsa20
        let mut i = 0;
        let mut c = 0;
        loop {
            if i >= m.len() {
                break;
            } else {
                let mut vi = [0; 16];
                for j in 0..8 {
                    vi[j] = v[j];
                }

                let counter: [u8; 8] = little_endian_inv64(c as u64);
                for j in 0..8 {
                    vi[j+8] = counter[j];
                }

                // generate salsa20 128bit expansion
                let expansion = Salsa20::salsa20_expansion_128(k, vi);

                // perform salsa20 core
                let bytes = Salsa20::salsa20(expansion);

                // copy generated bytes to output whilst XORing them with the
                // provided message truncating the length to m.len().
                if (m.len() - i) >= 64 {
                    for j in 0..64 {
                        r[i + j] = bytes[j] ^ m[i + j];
                    }
                } else {
                    for j in 0..(m.len() % 64) {
                        r[i + j] = bytes[j] ^ m[i + j];
                    }
                }

                i += 64;
                c += 1;
            }
        }
        r
    }

    // Salsa20/20 256-bit
    pub fn salsa20_20_256(k0: [u8; 16], k1: [u8; 16], v: [u8; 8], m: Vec<u8>) -> Vec<u8> {
        let mut r = vec![0; m.len()];
        let mut i = 0;
        let mut c = 0;
        loop {
            if i >= m.len() {
                break;
            } else {
                let mut vi = [0; 16];
                for j in 0..8 {
                    vi[j] = v[j];
                }

                let counter: [u8; 8] = little_endian_inv64(c as u64);
                for j in 0..8 {
                    vi[j+8] = counter[j];
                }

                // generate salsa20 constants
                let expansion = Salsa20::salsa20_expansion_256(k0, k1, vi);

                // run salsa20/20
                let bytes = Salsa20::salsa20(expansion);

                // copy generated bytes to output whilst XORing them with the
                // provided message truncating the length to m.len().
                if (m.len() - i) >= 64 {
                    for j in 0..64 {
                        r[i + j] = bytes[j] ^ m[i + j];
                    }
                } else {
                    for j in 0..(m.len() % 64) {
                        r[i + j] = bytes[j] ^ m[i + j];
                    }
                }

                i += 64;
                c += 1
            }
        }
        r
    }

    // XSalsa20/20 256-bit
    pub fn xsalsa20_20_256(mut k0: [u8; 16], mut k1: [u8; 16], v: [u8; 24], m: Vec<u8>) -> Vec<u8> {
        // Use the first 128-bits of v as initial nonce for HSalsa20
        let mut vi = [0; 16];
        for i in 0..16 {
            vi[i] = v[i];
        }

        // Use the last 64-bits of v as initial nonce for Salsa20
        let mut vj = [0; 16];
        for i in 0..8 {
            vj[i] = v[i+16];
        }

        // Generate salsa constant for HSalsa
        let expansion = Salsa20::salsa20_expansion_256(k0, k1, vi);

        // Perform hsalsa20/20 -> 256-bit output key
        let k = Salsa20::hsalsa20(expansion);
        for i in 0..16 {
            k0[i] = k[i];
            k1[i] = k[i+16];
        }

        let mut r = vec![0; m.len()];
        let mut i = 0;
        let mut c = 0;
        loop {
            if i >= m.len() {
                break
            } else {
                let counter: [u8; 8] = little_endian_inv64(c as u64);
                for j in 0..8 {
                    vj[j+8] = counter[j];
                }

                // generate salsa constant for XSalsa
                let expansion = Salsa20::salsa20_expansion_256(k0, k1, vj);

                // perform salsa20/20 using hsalsa20/12 output -> 512-bit output
                let bytes = Salsa20::salsa20(expansion);

                // copy generated bytes to output whilst XORing them with the
                // provided message truncating the length to m.len().
                if (m.len() - i) >= 64 {
                    for j in 0..64 {
                        r[i + j] = bytes[j] ^ m[i + j];
                    }
                } else {
                    for j in 0..(m.len() % 64) {
                        r[i + j] = bytes[j] ^ m[i + j];
                    }
                }

                i += 64;
                c += 1;
            }
        }
        r
    }
}

pub fn bytes_eq(v1: Vec<u8>, v2: Vec<u8>) -> bool {
    if v1.len() != v2.len() {
        false
    } else {
        for i in 0..v1.len() {
            if v1[i] != v2[i] {
                return false;
            }
        }
        true
    }
}

pub fn xor_digest(enc: Vec<u8>) -> Vec<u8> {
    let mut r = vec![0; 64];
    let mut i = 0;
    loop {
        if i >= enc.len() / 64 {
            break;
        } else {
            if enc.len() >= i * 64 + 64 {
                for j in 0..64 {
                    let p = i * 64 + j;
                    r[p % 64] = r[p % 64] ^ enc[p];
                }
            } else {
                for j in 0..enc.len() % 64 {
                    let p = i * 64 + j;
                    r[p % 64] = r[p % 64] ^ enc[p];
                }
            }
            i += 1;
        }
    }
    r
}

fn little_endian(b: [u8; 4]) -> u32 {
    b[0] as u32 + ((b[1] as u32) << 8) + ((b[2] as u32) << 16) + ((b[3] as u32) << 24)
}

fn little_endian_inv(x: u32) -> [u8; 4] {
    let mut bytes: [u8; 4] = [0; 4];
    bytes[0] = (x & 0xFF) as u8;
    for i in 1..4 {
        bytes[i] = ((x & (0xFF << i * 8)) >> i * 8) as u8;
    }
    bytes
}

pub fn little_endian_inv64(x: u64) -> [u8; 8] {
    let mut bytes: [u8; 8] = [0; 8];
    bytes[0] = (x & 0xFF) as u8;
    for i in 1..8 {
        bytes[i] = ((x & (0xFF << i * 8)) >> i * 8) as u8;
    }
    bytes
}

#[cfg(test)]
mod tests {
    use super::*;
    use rustc_serialize::hex::FromHex;

    #[test]
    fn test_quarter_round() {
        let test_v1 = [0x00000000, 0x00000000, 0x00000000, 0x00000000];
        let test_r1 = [0x00000000, 0x00000000, 0x00000000, 0x00000000];
        assert_eq!(Salsa20::quarter_round(test_v1), test_r1);
        let test_v2 = [0x00000001, 0x00000000, 0x00000000, 0x00000000];
        let test_r2 = [0x08008145, 0x00000080, 0x00010200, 0x20500000];
        assert_eq!(Salsa20::quarter_round(test_v2), test_r2);
    }

    #[test]
    fn test_row_round() {
        let test_v1 = [
            0x00000001, 0x00000000, 0x00000000, 0x00000000,
            0x00000001, 0x00000000, 0x00000000, 0x00000000,
            0x00000001, 0x00000000, 0x00000000, 0x00000000,
            0x00000001, 0x00000000, 0x00000000, 0x00000000,
        ];
        let test_r1 = [
            0x08008145, 0x00000080, 0x00010200, 0x20500000,
            0x20100001, 0x00048044, 0x00000080, 0x00010000,
            0x00000001, 0x00002000, 0x80040000, 0x00000000,
            0x00000001, 0x00000200, 0x00402000, 0x88000100,
        ];
        assert_eq!(Salsa20::row_round(test_v1), test_r1);
    }

    #[test]
    fn test_column_round() {
        let test_v1 = [
            0x00000001, 0x00000000, 0x00000000, 0x00000000,
            0x00000001, 0x00000000, 0x00000000, 0x00000000,
            0x00000001, 0x00000000, 0x00000000, 0x00000000,
            0x00000001, 0x00000000, 0x00000000, 0x00000000,
        ];
        let test_r1 = [
            0x10090288, 0x00000000, 0x00000000, 0x00000000,
            0x00000101, 0x00000000, 0x00000000, 0x00000000,
            0x00020401, 0x00000000, 0x00000000, 0x00000000,
            0x40a04001, 0x00000000, 0x00000000, 0x00000000,
        ];
        assert_eq!(Salsa20::column_round(test_v1), test_r1)
    }

    #[test]
    fn test_double_round() {
        let test_v1 = [
            0x00000001, 0x00000000, 0x00000000, 0x00000000,
            0x00000000, 0x00000000, 0x00000000, 0x00000000,
            0x00000000, 0x00000000, 0x00000000, 0x00000000,
            0x00000000, 0x00000000, 0x00000000, 0x00000000,
        ];
        let test_r1 = [
            0x8186a22d, 0x0040a284, 0x82479210, 0x06929051,
            0x08000090, 0x02402200, 0x00004000, 0x00800000,
            0x00010200, 0x20400000, 0x08008104, 0x00000000,
            0x20500000, 0xa0000040, 0x0008180a, 0x612a8020,
        ];
        assert_eq!(Salsa20::double_round(test_v1), test_r1)
    }

    #[test]
    fn test_little_endian() {
        let test_v1 = [0, 0, 0, 0];
        assert_eq!(little_endian(test_v1), 0);
        assert_eq!(little_endian_inv(0), test_v1);
        let test_v2 = [86, 75, 30, 9];
        assert_eq!(little_endian(test_v2), 0x091e4b56);
        assert_eq!(little_endian_inv(0x091e4b56), test_v2);
        let test_v3 = [255, 255, 255, 250];
        assert_eq!(little_endian(test_v3), 0xfaffffff);
        assert_eq!(little_endian_inv(0xfaffffff), test_v3);
    }

    #[test]
    fn test_salsa20() {
        let test_v1 = [
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        let r1 = Salsa20::salsa20(test_v1);
        let mut r1_result = true;
        for i in 0..64 {
            if r1[i] != test_v1[i] {
                r1_result = false;
            }
        }
        assert_eq!(r1_result, true);

        let test_v2 = [
            211,159, 13,115, 76, 55, 82,183, 3,117,222, 37,191,187,234,136,
            49,237,179, 48, 1,106,178,219,175,199,166, 48, 86, 16,179,207,
            31,240, 32, 63, 15, 83, 93,161,116,147, 48,113,238, 55,204, 36,
            79,201,235, 79, 3, 81,156, 47,203, 26,244,243, 88,118,104, 54,
        ];
        let test_r2 = [
            109, 42,178,168,156,240,248,238,168,196,190,203, 26,110,170,154,
            29, 29,150, 26,150, 30,235,249,190,163,251, 48, 69,144, 51, 57,
            118, 40,152,157,180, 57, 27, 94,107, 42,236, 35, 27,111,114,114,
            219,236,232,135,111,155,110, 18, 24,232, 95,158,179, 19, 48,202,
        ];

        let r2 = Salsa20::salsa20(test_v2);
        let mut r2_result = true;
        for i in 0..64 {
            if r2[i] != test_r2[i] {
                r2_result = false;
            }
        }
        assert_eq!(r2_result, true);
    }

    #[test]
    fn test_salsa20_expansion_128() {
        let k0 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16];
        let n = [101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116];
        let test_v1 = [
            39,173, 46,248, 30,200, 82, 17, 48, 67,254,239, 37, 18, 13,247,
            241,200, 61,144, 10, 55, 50,185, 6, 47,246,253,143, 86,187,225,
            134, 85,110,246,161,163, 43,235,231, 94,171, 51,145,214,112, 29,
            14,232, 5, 16,151,140,183,141,171, 9,122,181,104,182,177,193,
        ];
        let expansion = Salsa20::salsa20_expansion_128(k0, n);
        let r1 = Salsa20::salsa20(expansion);
        let mut r1_result = true;
        for i in 0..64 {
            if r1[i] != test_v1[i] {
                println!("{}: {} != {}: {}", i, r1[i], i, test_v1[i]);
                r1_result = false;
            }
        }
        assert_eq!(r1_result, true);
    }

    #[test]
    fn test_salsa20_expansion_256() {
        let k0 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16];
        let k1 = [201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216];
        let n = [101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116];
        let test_v1 = vec![
            69, 37, 68, 39, 41, 15,107,193,255,139,122, 6,170,233,217, 98,
            89,144,182,106, 21, 51,200, 65,239, 49,222, 34,215,114, 40,126,
            104,197, 7,225,197,153, 31, 2,102, 78, 76,176, 84,245,246,184,
            177,160,133,130, 6, 72,149,119,192,195,132,236,234,103,246, 74,
        ];
        let expansion = Salsa20::salsa20_expansion_256(k0, k1, n);
        let r1 = Salsa20::salsa20(expansion);
        assert_eq!(bytes_eq(r1.to_vec(), test_v1), true);
    }

    #[test]
    fn test_hsalsa20_expansion_256() {
        let k0 = [ 0x4a,0x5d,0x9d,0x5b,0xa4,0xce,0x2d,0xe1
                 , 0x72,0x8e,0x3b,0xf4,0x80,0x35,0x0f,0x25];
        let k1 = [ 0xe0,0x7e,0x21,0xc9,0x47,0xd1,0x9e,0x33
                 , 0x76,0xf0,0x9b,0x3c,0x1e,0x16,0x17,0x42];
        let n = [0x00; 16];
        let test_r1 = vec![ 0x1b,0x27,0x55,0x64,0x73,0xe9,0x85,0xd4
                      , 0x62,0xcd,0x51,0x19,0x7a,0x9a,0x46,0xc7
                      , 0x60,0x09,0x54,0x9e,0xac,0x64,0x74,0xf2
                      , 0x06,0xc4,0xee,0x08,0x44,0xf6,0x83,0x89];
        // Generate salsa constant for HSalsa
        let c = Salsa20::salsa20_expansion_256(k0, k1, n);
        // Perform hsalsa20/20 -> 256-bit output key
        let r1 = Salsa20::hsalsa20(c);
        assert_eq!(bytes_eq(r1.to_vec(), test_r1), true);
    }

    #[test]
    fn test_salsa20_encrypt_128() {
        let k = [0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
        let v = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
        let m = vec![0; 512];
        // encrypt message
        let r1 = Salsa20::salsa20_20_128(k, v, m.clone());
        // decrypt message
        let m1 = Salsa20::salsa20_20_128(k, v, r1.clone());
        let d1 = xor_digest(r1.clone());
        let test_s1_xor_digest = vec![
            0xF7, 0xA2, 0x74, 0xD2, 0x68, 0x31, 0x67, 0x90, 0xA6, 0x7E, 0xC0, 0x58, 0xF4, 0x5C, 0x0F, 0x2A,
            0x06, 0x7A, 0x99, 0xFC, 0xDE, 0x62, 0x36, 0xC0, 0xCE, 0xF8, 0xE0, 0x56, 0x34, 0x9F, 0xE5, 0x4C,
            0x5F, 0x13, 0xAC, 0x74, 0xD2, 0x53, 0x95, 0x70, 0xFD, 0x34, 0xFE, 0xAB, 0x06, 0xC5, 0x72, 0x05,
            0x39, 0x49, 0xB5, 0x95, 0x85, 0x74, 0x21, 0x81, 0xA5, 0xA7, 0x60, 0x22, 0x3A, 0xFA, 0x22, 0xD4,
        ];
        // encrypted message
        assert_eq!(bytes_eq(d1, test_s1_xor_digest), true);
        // decrypted message
        assert_eq!(bytes_eq(m, m1), true);
    }

    #[test]
    fn test_salsa20_encrypt_256() {
        let k0 = [0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
        let k1 = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
        let v = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
        let m = vec![0; 512];
        // encrypt message
        let r1 = Salsa20::salsa20_20_256(k0, k1, v, m.clone());
        // decrypt message
        let m1 = Salsa20::salsa20_20_256(k0, k1, v, r1.clone());
        let d1 = xor_digest(r1.clone());
        let test_s1_xor_digest = vec![
            0x50, 0xEC, 0x24, 0x85, 0x63, 0x7D, 0xB1, 0x9C, 0x6E, 0x79, 0x5E, 0x9C, 0x73, 0x93, 0x82, 0x80,
            0x6F, 0x6D, 0xB3, 0x20, 0xFE, 0x3D, 0x04, 0x44, 0xD5, 0x67, 0x07, 0xD7, 0xB4, 0x56, 0x45, 0x7F,
            0x3D, 0xB3, 0xE8, 0xD7, 0x06, 0x5A, 0xF3, 0x75, 0xA2, 0x25, 0xA7, 0x09, 0x51, 0xC8, 0xAB, 0x74,
            0x4E, 0xC4, 0xD5, 0x95, 0xE8, 0x52, 0x25, 0xF0, 0x8E, 0x2B, 0xC0, 0x3F, 0xE1, 0xC4, 0x25, 0x67,
        ];
        // encrypted message
        assert_eq!(bytes_eq(d1, test_s1_xor_digest), true);
        // decrypted message
        assert_eq!(bytes_eq(m, m1), true);
    }

    #[test]
    fn test_xsalsa20_encrypt_256() {
        let key = "a6a7251c1e72916d11c2cb214d3c252539121d8e234e652d651fa4c8cff88030"
            .from_hex()
            .expect("");
        let iv = "9e645a74e9e0a60d8243acd9177ab51a1beb8d5a2f5d700c"
            .from_hex()
            .expect("");
        let plaintext = "093c5e5585579625337bd3ab619d615760d8c5b224a85b1d0efe0eb8a7ee163abb0376529fcc09bab506c618e13ce777d82c3ae9d1a6f972d4160287cbfe60bf2130fc0a6ff6049d0a5c8a82f429231f008082e845d7e189d37f9ed2b464e6b919e6523a8c1210bd52a02a4c3fe406d3085f5068d1909eeeca6369abc981a42e87fe665583f0ab85ae71f6f84f528e6b397af86f6917d9754b7320dbdc2fea81496f2732f532ac78c4e9c6cfb18f8e9bdf74622eb126141416776971a84f94d156beaf67aecbf2ad412e76e66e8fad7633f5b6d7f3d64b5c6c69ce29003c6024465ae3b89be78e915d88b4b5621d"
            .from_hex()
            .expect("");
        let ciphertext = "b2af688e7d8fc4b508c05cc39dd583d6714322c64d7f3e63147aede2d9534934b04ff6f337b031815cd094bdbc6d7a92077dce709412286822ef0737ee47f6b7ffa22f9d53f11dd2b0a3bb9fc01d9a88f9d53c26e9365c2c3c063bc4840bfc812e4b80463e69d179530b25c158f543191cff993106511aa036043bbc75866ab7e34afc57e2cce4934a5faae6eabe4f221770183dd060467827c27a354159a081275a291f69d946d6fe28ed0b9ce08206cf484925a51b9498dbde178ddd3ae91a8581b91682d860f840782f6eea49dbb9bd721501d2c67122dea3b7283848c5f13e0c0de876bd227a856e4de593a3"
            .from_hex()
            .expect("");

        let mut k0: [u8; 16] = [0; 16];
        let mut k1: [u8; 16] = [0; 16];
        let mut v: [u8; 24] = [0; 24];
        for i in 0..16 {
            k0[i] = key[i];
            k1[i] = key[i+16];
        }
        for i in 0..24 {
            v[i] = iv[i];
        }

        let rs = Salsa20::xsalsa20_20_256(k0, k1, v, plaintext.clone());

        assert_eq!(bytes_eq(rs.to_vec(), ciphertext), true);
    }
}
