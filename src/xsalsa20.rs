use super::*;
use salsa20::Salsa20;
use hsalsa20::HSalsa20;

pub struct XSalsa20;

impl XSalsa20 {

    pub fn random_u64(seed: [u8; 32]) -> u64 {
        let mut k0 = [0; 16];
        let mut k1 = [0; 16];
        for i in 0..16 {
            k0[i] = seed[i];
            k1[i] = seed[i+16];
        }
        let v = [0; 24];
        let m = vec![0; 8];
        let bytes = XSalsa20::xsalsa20_20_256(k0, k1, v, m);
        let mut r = [0; 8];
        for i in 0..8 {
            r[i] = bytes[i];
        }
        little_endian_u64(r)
    }

    // XSalsa20/20 256-bit
    pub fn xsalsa20_20_256(mut k0: [u8; 16], mut k1: [u8; 16], v: [u8; 24], m: Vec<u8>) -> Vec<u8> {
        // Use the first 128-bits of v as initial nonce for HSalsa20
        let mut vi = [0; 16];
        for i in 0..16 {
            vi[i] = v[i];
        }

        // Use the last 64-bits of v as initial nonce for Salsa20
        let mut vj = [0; 16];
        for i in 0..8 {
            vj[i] = v[i+16];
        }

        // Generate salsa constant for HSalsa
        let expansion = Salsa20::salsa20_expansion_256(k0, k1, vi);

        // Perform hsalsa20/20 -> 256-bit output key
        let k = HSalsa20::hsalsa20(expansion);
        for i in 0..16 {
            k0[i] = k[i];
            k1[i] = k[i+16];
        }

        let mut r = vec![0; m.len()];
        let mut i = 0;
        let mut c = 0;
        loop {
            if i >= m.len() {
                break
            } else {
                let counter: [u8; 8] = little_endian_inv64(c as u64);
                for j in 0..8 {
                    vj[j+8] = counter[j];
                }

                // generate salsa constant for XSalsa
                let expansion = Salsa20::salsa20_expansion_256(k0, k1, vj);

                // perform salsa20/20 using hsalsa20/12 output -> 512-bit output
                let bytes = Salsa20::salsa20(expansion);

                // copy generated bytes to output whilst XORing them with the
                // provided message truncating the length to m.len().
                if (m.len() - i) >= 64 {
                    for j in 0..64 {
                        r[i + j] = bytes[j] ^ m[i + j];
                    }
                } else {
                    for j in 0..(m.len() % 64) {
                        r[i + j] = bytes[j] ^ m[i + j];
                    }
                }

                i += 64;
                c += 1;
            }
        }
        r
    }
}
